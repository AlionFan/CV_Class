<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dataset</title>
    <link rel="stylesheet" href="/CV_Class/assets/css/styles.css">
    <!-- Prism.js CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
  </head>
  <body>
    <header class="site-header">
  <div class="wrapper">
    
    <a class="site-title" href="/CV_Class/">计算机视觉课程作业汇总</a>
    <nav class="site-nav">
      
        <a href="/CV_Class/" >
          Home
        </a>
      
        <a href="/CV_Class/assignment.html" >
          Assignment
        </a>
      
        <a href="/CV_Class/code.html" >
          Code
        </a>
      
        <a href="/CV_Class/homework.html"  class="current">
          每周作业
        </a>
      
    </nav>

  </div>
</header>

    <div class="dataset-page">
    <div class="dataset-sidebar">
        <ul class="dataset-nav">
            <li><a href="#work1" class="active" data-content="work1">1. First Attempt</a></li>
            <li><a href="#work2" data-content="work2">2. Edge Detection</a></li>
            <li><a href="#work3" data-content="work3">3. Future Work</a></li>
        </ul>
    </div>

    <div class="dataset-content">
        <div id="work1-content" class="work-content active">
            <!-- 第一周作业内容 -->
<div id="work1">
    <h1>第一周作业</h1>
    <h2>1. 原图像</h2>
    
    <div class="image-container1">
        <img src="/CV_Class/works/work1/pic/hg.jpg" alt="胡歌" />
        <img src="/CV_Class/works/work1/pic/wyz.jpg" alt="吴彦祖" />
    </div>
    
    <h3>代码实现：</h3>
    <h4>1. 使用HSV颜色空间进行图像分割</h4>
    <pre><code class="language-python">
import cv2
import numpy as np

hg = cv2.imread("./pic/hg.jpg")  # ./pic/wyz.jpg
hg_hsv = cv2.cvtColor(hg, cv2.COLOR_BGR2HSV)

min_HSV = np.array([0, 10, 80], dtype="uint8")
max_HSV = np.array([33, 255, 255], dtype="uint8")
mask = cv2.inRange(hg_hsv, min_HSV, max_HSV)
result = cv2.bitwise_and(hg, hg, mask=mask)

cv2.imshow("img", hg)
cv2.imshow("result", result)
cv2.waitKey()
cv2.destroyAllWindows()
    </code></pre>

    <h4>2. 多种实现方法</h4>
    <pre><code class="language-python">
import cv2
import numpy as np

# canny 边缘检测
def canny_edge_detection(image, low_threshold=100, high_threshold=200):
    # 转换为灰度图像
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    # 使用Canny边缘检测
    edges = cv2.Canny(gray, low_threshold, high_threshold)
    return edges

# 课上方法，添加蒙版
def add_mask_detect(image, min_HSV=[0, 10, 80], max_HSV=[33, 255, 255]):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)  # BGR转化为HSV格式
    min_HSV = np.array(min_HSV, dtype="uint8")
    max_HSV = np.array(max_HSV, dtype="uint8")
    mask = cv2.inRange(hsv, min_HSV, max_HSV)
    result = cv2.bitwise_and(image, image, mask=mask)
    return result

def sobel_edge_detection(image, ksize=3):
    # 转换为灰度图像
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    # 计算x和y方向的梯度
    sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=ksize)
    sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=ksize)
    # 计算梯度幅值
    sobel = np.sqrt(sobelx**2 + sobely**2)
    # 转换为8位图像
    sobel = np.uint8(sobel)
    return sobel

def laplacian_edge_detection(image, ksize=3):
    # 转换为灰度图像
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    # 使用Laplacian算子
    laplacian = cv2.Laplacian(gray, cv2.CV_64F, ksize=ksize)
    # 转换为8位图像
    laplacian = np.uint8(np.absolute(laplacian))
    return laplacian

# 读取图像
image = cv2.imread('pic/hg.jpg')
# 调用Canny边缘检测函数
edges = canny_edge_detection(image)
edges = add_mask_detect(image)
edges = sobel_edge_detection(image)
edges = laplacian_edge_detection(image)

# 显示结果
cv2.imshow('Canny Edge Detection', edges)
cv2.waitKey()
cv2.destroyAllWindows()
    </code></pre>
    
    <h3>实验结果分析：</h3>
    <p>
        本实验使用HSV颜色空间进行图像分割。通过设定HSV的阈值范围（色调：0-33，饱和度：10-255，亮度：80-255），
        成功提取出图像中的黄色区域。使用位运算（bitwise_and）将掩码应用于原图，得到只保留黄色区域的结果图像。
    </p>
</div> 
        </div>

        <div id="work2-content" class="work-content">
            <div id="work2">
    <h1>第二周作业</h1>
    <h2>1. 边缘检测</h2>
    <div class="image-container1">
        <img src="/CV_Class/works/work1/pic/hg.jpg" alt="胡歌" />
        <img src="/CV_Class/works/work1/pic/hg.jpg" alt="吴彦祖" />
    </div>
    
    <h3>代码实现：</h3>
    <pre><code class="python">
import cv2
import numpy as np

# 读取图像
img = cv2.imread('original.jpg')
# 转换为灰度图
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# 使用Canny算子进行边缘检测
edges = cv2.Canny(gray, 100, 200)

cv2.imshow('Original', img)
cv2.imshow('Edges', edges)
cv2.waitKey(0)
cv2.destroyAllWindows()
    </code></pre>
    
    <h3>实验结果分析：</h3>
    <p>
        使用Canny边缘检测算法对图像进行处理。该算法首先对图像进行高斯滤波以去除噪声，
        然后计算图像梯度的幅值和方向，接着进行非极大值抑制，最后通过双阈值检测和连接边缘。
        从结果可以看出，算法成功检测出了图像中的主要边缘特征。
    </p>
</div> 
        </div>

        <div id="work3-content" class="work-content">
            <!-- 第三周作业内容 -->
<div id="work3">
    <h1>第三周作业</h1>
    <h2>1. 待完成的工作</h2>
    
    <div class="future-work">
        <h3>计划完成的任务：</h3>
        <ul>
            <li>图像分割算法的实现</li>
            <li>目标检测模型的训练</li>
            <li>实时视频处理功能的开发</li>
        </ul>
        
        <h3>预期目标：</h3>
        <p>
            通过实现上述功能，构建一个完整的计算机视觉处理系统，
            能够对图像和视频进行实时处理和分析。
        </p>
    </div>
</div> 
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // 获取所有导航链接和内容区域
    const navLinks = document.querySelectorAll('.dataset-nav a');
    const contentDivs = document.querySelectorAll('.work-content');

    // 为每个导航链接添加点击事件
    navLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            
            // 移除所有导航链接的active类
            navLinks.forEach(a => a.classList.remove('active'));
            // 为当前点击的链接添加active类
            this.classList.add('active');

            // 隐藏所有内容
            contentDivs.forEach(div => div.classList.remove('active'));
            
            // 显示对应的内容
            const contentId = this.getAttribute('data-content') + '-content';
            document.getElementById(contentId).classList.add('active');
        });
    });
});
</script>

<footer style="text-align: center; margin-top: 20px; padding: 10px; background-color: #f5f5f5;">
    <p>© Copyright Capital Normal University 2025</p>
</footer>



    <!-- Prism.js JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
  </body>
</html>
